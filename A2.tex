% Title:   UofT Art & Sciences Assignment Sample File
% Version: 1.00
% Author:  Kaveh Ghasemloo
% Date:    Sept. 28, 2012
%
% Licence: 
% This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

\documentclass[10pt]{csc_assignment}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{qtree}

% ----------------------------------------------------------------
% TODO: Enter the assignment number, your name, and your student number below
% ----------------------------------------------------------------
\AssignmentName{2}
\QuestionCount{5}
\StudentName{John Armstrong, Henry Ku}
\StudentNumber{993114492\textbackslash g2jarmst, 998551348\textbackslash g2kuhenr}

% ----------------------------------------------------------------
\begin{document}


\Acknowledgements{
% ----------------------------------------------------------------
% TODO: Write your acknowledgements below.
% ----------------------------------------------------------------

"We declare that we have not used any outside help in completing this assignment."

% ----------------------------------------------------------------
% Aacknowledgements ends
% ----------------------------------------------------------------
}
\begin{description}

\newpage
\item[Q1.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{An nxn matrix R such that R[i, j] represents the ratio r$_{ij}$, also R[i, j] = 0 where i = j.}
 \KwOut{\emph{True} if we end up with more of our favourite marbles from some friend x$_{i}$ after initiating a marbling cycle, \emph{False} otherwise.}
 D$^{(0)} = R$\;
 \For{k: 1 ... n}{
 Let D$^{(k)}$ = d$_{ij}^{(k)}$ be an nxn matrix\;
 \For{i: 1 ... n}{
 \For{j: 1 ... n}{
 \If{i = k}{
 d$_{ij}^{(k)}$ = d$_{ij}^{(k-1)}$
 }
 \Else{
 d$_{ij}^{(k)}$ = max(d$_{ij}^{(k-1)}$, d$_{ik}^{(k-1)}$ * d$_{kj}^{(k-1)}$)\;
 }
 \If{d$_{ij}^{(k)}$ * r$_{ji}$ \textgreater ~1}{
 return True\;
 }
 }
 }
 }
 return False\;
\end{algorithm}
\emph{\underline{Running Time}}\\
\emph{Lines 2-16:} O(n$^{3}$) due to triple nested loop.\\
\emph{All other lines:} O(1).\\
\\
\emph{\underline{Description}}\\
The algorithm is an augmented version of Floyd-Warshall as presented 
in CLRS. Because we do not know which series exchanges will give a 
total product greater than one, it makes sense to use an all-pairs
algorithm. However, instead of looking at each pass whether the
length of the path between a pair of vertices could be made more 
minimal we are looking for the a series of exchanges that connect
two vertices where the product of exchanges can be maximized.\\
Essentially the recursive definition is defined as follows:\\
\[
d_{ij}^{(k)} = 
\begin{cases} 
      \hfill r_{ij}    \hfill & \text{ if $k$ = 0} \\
      \hfill max(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} * d_{kj}^{(k-1)})\hfill & \text{ if $k$ $\geqslant$ 1} \\
  \end{cases}
\]\\
At each update of d$_{ij}^{(k)}$ we perform d$_{ij}^{(k)}$ * r$_{ji}$. 
If the result is greater than 1 then we have marbling cycle (cycle
 of exchanges) that is favourable. Thus True is returned. 
 False is returned if the algorithm cannot locate a favourable
 cycle.\\
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q2.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list of jobs J = \{(T$_{1}$, O$_{1}$), ..., (T$_{n}$, O$_{n}$)\} where (T$_{i}$ and O$_{i}$ are both jobs during the same timeslot)}
 \KwOut{A sequence S of n locations that maximizes v(S), where location i represents the clinic you will work at during month i and v(S) is the total value of your savings}
G(V,E)\;
G.V = \{T$_{1}$, ..., T$_{n}$\} $\cup$ \{O$_{1}$, ..., O$_{n}$\} $\cup$ \{start, end\} \#start is start vertex and end is end vertex \;
\# let w be the weight function.\\
\# To get a path with largest income all income weights are made negative because DAG-SHORTEST-PATH looks for shortest path.\\
\# let T$_{i}$.pay and O$_{i}$.pay be value of pay for location T or O on month i\\
G.addEdge(start, T$_{1}$)\;
w(start,T$_{1}$) = -(T$_{1}$.pay)\;
G.addEdge(start, O$_{1}$)\;
w(start,O$_{1}$) = -(O$_{1}$.pay)\;
\For{i: 1 ... n - 1}{
G.addEdge(T$_{i}$, T$_{i+1}$)\;
w(T$_{i}$,T$_{i+1}$) = -(T$_{i+1}$.pay)\;
G.addEdge(O$_{i}$, O$_{i+1}$)\;
w(O$_{i}$, O$_{i+1}$) = -(O$_{i+1}$.pay)\;
G.addEdge(T$_{i}$, O$_{i+1}$)\;
w(T$_{i}$,O$_{i+1}$) = -(O$_{i+1}$.pay - move\_fee)\;
G.addEdge(O$_{i}$, T$_{i+1}$)\;
 w(O$_{i}$,T$_{i+1}$) = -(T$_{i+1}$.pay - move\_fee)\;
}
G.addEdge(T$_{n}$, end)\;
w(T$_{n}$, end) = -(T$_{n}$.pay)\;
G.addEdge(O$_{n}$, end)\;
w(O$_{n}$, end) = -(O$_{n}$.pay)\;
 \# Using the DAG-SHORTEST-PATHS algorithm in CLRS Chap 24.2 \\
DAG-SHORTEST-PATHS(G,w, start)\;
S=[]\;
return ShortPath(G, start, end, S=[])\;
\end{algorithm}

\LinesNumbered
\begin{algorithm}[H]
 \SetKwFunction{ShortPath}{ShortPath}
 \SetKwProg{myprocone}{}{}{}
 \myprocone{\ShortPath{G, start, end, S}}{
\If {end == start  \# when we finish making the path}{
S.prepend(start) \#add the vertex to start of the S sequence\;
\# return S but remove "start" and "end" vertices from S\\
return (S[1: -1])}
\ElseIf{end.parent == NIL \# no path available}{
return [];
}
\Else{
S.prepend(end)\;
ShortPath(G,start, end.parent, S)\;
}}
\end{algorithm}

\emph{\underline{Description}}\\
The algorithm sets up the question by establish a graph with a start and end vertices. \\
The start vertex connects to T$_{1}$ with an edge, and O$_{1}$ with another edge.\\
The end vertex connects to T$_{n}$ with an edge, and O$_{n}$ with another edge.\\
The start and end vertices and their edges all have weight 0 to provide no impact on the question.\\
Each vertex T$_{i}$ will connect to T$_{i+1}$ vertex with an edge of weight 0, and connect to O$_{i+1}$ with an edge of 3.\\
The edge has the weight 3 as we are converting the questions into a shortest path question, by multiplying all edge and vertex weight by -1 and this represent the cost of transferring between hospital.\\
Each vertex will have the weight of their income amount multiply by -1 as mentioned above.\\
Then we uses the DAG-SHORTEST-PATHS algorithm to find the shortest path which in this case maximize our income\\
Then with the graph we use Short-Path to generate the sequence of our pathing and also return our max income.\\
ShortPath is based on chap 22.2 Print-Path algorithm\\

\emph{\underline{Running Time}}\\

lines 1-7,23,24,26 takes O(1) \\
lines 7-20 are O(n)\\
lines 22 is using DAG-SHORTEST-PATHS takes O(n+e) where n is number of vertices, and e is number of edges.\\
and since the number of edge e is 4*(n-1)+4 thus it is O(n+n) which is O(n) \\
line 25 uses the Short Path algorithm and it takes O(n) for the number of n vertices\\
So the algorithm is bounded by O(n) \\
\emph{\underline{Proof}}\\
topological sorts the algorithm to make sure that the sorted list has them in order of a directed acyclic graph.
we init single source by setting all vertices' destination to infinite, and their parents to NIL, then set the start vertex's destination to 0.

% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q3.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q4.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list \emph{A} of n houses and a list \emph{B} of m hospitals, where every house and hospital is represented by a pair (x, y) on the plane, and s and t}
 \KwOut{"Good" if each household has access to ahospital under the restrictions listed in the question, and "Eeek" otherwise.}
 \# Empty graph\;
 G(V, E)\;
 G.V = A $\cup$ B $\cup$ \{ T, S \} \;
 \For{i: 1 ... m}{
 G.addEdge(B[i], T)\;
 G.capacity(B[i], T) = t\
 }
 \For{j: 1 ... n}{
 G.addEdge(S, A[j])\;
 G.capacity(S, A[i]) = 1\;
 }
 \For{i: 1 ... m}{
 \For{j: 1 ... n}{
 \# d(u, v) is a distance function\;
 \If{d(A[j], B[i]) $\leqslant$ s}{ 
    G.addEdge(A[j], B[i])\; 
    G.capacity(A[j], B[i]) = 1\;
 }
 }
 } 
  \# Using the algorithm in CLRS Chap 26.2 with the assumptions that max flow for network G is returned\;
 maxFlow = FordFulkerson(G, S, T)\;
 \If{maxFlow = length(HS)}{
 return 'Good'\;
 }
 \Else{
 return 'Eeek!'\;
 }
 
\end{algorithm}
\emph{\underline{Description}}\\
The solution is to firstly generate a bipartite graph.
This involves firstly iteratively connecting nodes i from A (houses) with an edge to node(s) j from B (hospitals) only if  d(i, j) $\leqslant$ s. Each of these edges is assigned c(i, j) = 1. From the bipartite graph we add two vertices S, the source, T, the sink, and make the edges in all (i, j) directed from i to j. S is connected to each node i in A by directed edge (S, i), also c(S, i) = 1. Also, each node j in B is connected to T by directed edge (j, T), and c(j, T) = t (the maximum number of houses a hospital can deal with). We then produce the maximum flow value by executing the Ford Fulkerson algorithm on the graph. If the maximum flow returned equals n, the number of houses, this means that there are an adaquate number of hospitals in the area.\\
\\
\\
\emph{\underline{Running Time}}\\
\emph{Lines 3 - 6:} O(m)\\
\emph{Lines: 7 - 10:} O(n)\\
\emph{Lines: 11 - 19:} O(mn)\\
\emph{Line 21:} Normally, Ford Fulkerson algorithm is O(E $\mid$f*$\mid$) (CLRS p. 725). In this case $\mid$f*$\mid$, the largest possible max flow, is n, the maximum number of houses. From our constructed bipartite graph, E = (all edges connected to S) + (all edges connected to T) + (all edges between houses and hospitals) $\leqslant$ O(n) + O(m) + O(mn), so E $\leqslant$ O(mn). Therefore line 23 is O(mn$^{2}$). \\
It follows that the algorithm is dominated by O(mn$^{2}$).\\
\\
\emph{\underline{Proof}}\\
\textbf{Claim}\\
If the data given is such that all hospitals in B can accomodate the houses in A, then the 
algorithm returns the correct response, "Good". However, if there are too many
houses for the hospitals to deal with the algorithm returns "Eeek!". Thus, using a network 
flow as a representation of the data and as a method to determine our results, in each case,
we will receive an accurate outcome.\\
\textbf{Proof}\\
Suppose we have sets of A and B and we construct a bipartite graph with vertices i $\in$ A and j $\in$ B, and we form edges (i, j) and c(i, j) = 1 only when d(i, j) $\leqslant$ s. Then assume that a network flow is created in the same manner as described in the description above.\\
\emph{Case 1:} Suppose we know beforehand that the houses in A can be accomodated by the hospitals in B. In maximum flow, when the residual graph has no more augmenting paths, it would follow that in the network graph, for each house vertex i, there would be a path that passes through i, and some hospital vertex j, such that S $\rightarrow$ i $\rightarrow$ j $\rightarrow$ T. In constructing the network we have c(S, i) = 1, c(i, j) = 1, and c(j, T) = t. It would follow that for all i and some j, f(S, i) = f(i, j) = 1 and f(j, T) $\leqslant$ t \textemdash ~because we know for a fact that there are enough hospitals in the area for the houses, therefore flow within every i exists. If we cut anywhere within the maximum flow representation of the network \textemdash ~where we have sets where the source is seperated from the sink \textemdash ~then the summation of outgoing and incoming edge weights, by law of conservation, will be $\mid$A$\mid$. Therefore, as expected, string "Good" will be returned.\\    
\emph{Case 2:} Suppose instead that we know there are not enough hospitals in B for houses in A. It would follow either that (1) the number of houses is greater than the number of hospitals or (2) that some/all houses are not in the vacinity of any hospitals. Indeed, if we have (2) then the flow network graph, by the nature of construction, for some house i would have no edges to any hospitals j, thus no flow could pass from this i to a j, and so the lack of flow would illustrate that no hospital could accomodate i. To illustrate (1), suppose we have some house i, that is connected (near) to hospitals {j$_{0}$, ..., j$_{k}$}, k $\leqslant$ $\mid$B$\mid$. So, for any j$_{l}$, l $\in$ k, in the network flow there would exist a path S $\rightarrow$ i $\rightarrow$ j$_{l}$ $\rightarrow$ T. Then maximum flow along any of these paths would be such that f(S, i) = f(i, j$_{l}$) = 0 and f(j$_{l}$, T) = t. Specifically, flow from hospitals j$_{l}$ to the sink T must be at capacity t if it cannot accomodate house i, and f(S, i) and f(i, j$_{l}$) indicates that the hospital cannot handle i. It would follow that in both (1) and/or (2) that maximum flow would be less than $\mid$A$\mid$ because it has been shown that flow cannot exists between all houses and all hospitals. Therefore, as expected, string "Eeek!" will be returned.\\ 
By the explanation of cases 1 and 2 it must follow that in both circumstances the agorithm can accurately determine if a group of houses can be handled by a group of hospitals. Therefore the algorithm must be optimal.        
\\
    
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q5.]
% ----------------------------------------------------------------                                                                               
% TODO: Write your answer to the question below.                                                                                                 
% ----------------------------------------------------------------                                                                               

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
\SetKwFunction{modFordFulkerson}{modFordFulkerson}
 \KwIn{A list of job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} and a list of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}}
 \KwOut{If all tasks can be completed return a list of jobs each p$_{i}$ will have to complete, otherwise return false.}
\# Empty graph\\
G(V, E)\;
G.V = \{t$_{1}$, ..., t$_{k}$\} $\cup$ \{p$_{1}$, ..., p$_{n}$\} $\cup$ \{t, s\}\;
\For{i: 1 ... k}{
G.addEdge(t$_{i}$, T)\;
G.capacity(t$_{i}$, T) = c$_{i}$\;
\For{j: 1 ... n}{
G.addEdge(p$_{j}$, t$_{i}$)\;
G.capacity(p$_{j}$, t$_{i}$) = h$_{j}$\;
}
}
\For{j: 1 ... n}{
G.addEdge(S, p$_{j}$)\;
G.capacity(S, p$_{j}$) = h$_{j}$\;
}
(f, maxFlow) = \modFordFulkerson{G}\; 
\If{$\sum_{i = 1}^{k}$ c$_{i}$ = maxFlow(ie. if all tasks can be completed)}{
\ForEach{edge (u, v) in G}{
	\If{(u is a person and v is a task) and f(u, v) $\geqslant$ 1}{
		Get S$_{i}$ corresponding to u and add task v to S$_{i}$
	}
}
return P\;
}
\Else{
return False\;
} 
\end{algorithm}

\LinesNumbered 
\begin{algorithm}[H]
 \SetKwFunction{modFordFulkerson}{modFordFulkerson}
 \SetKwProg{myproc}{}{}{}
 \myproc{\modFordFulkerson{G}}{
\# will contain all maxflow values of edges in G\;
f = new flow object\;
\ForEach{edge (u, v) $\in$ E} {
	f(u, v) = 0\;
}
\While{there exists a path p from S to T in the residual network G$_{f}$}{
c$_{f}$(p) = min \{c$_{f}$(u, v) : (u, v) is in p\}
\ForEach{edge (u, v) in p}{
\If{(u, v) $\in$ E}{
f(u, v) = f(u, v) + c$_{f}$(p)\;
}
\Else{
f(v, u) = f(v, u) - c$_{f}$(p)\;
}
}
}
\# maxFlow the maximum flow as calculated and returned in the original Ford-Fulkerson\\
return (f, maxFlow)\;
}
\end{algorithm}

\emph{\underline{Proof of Correctness}}\\
\textbf{Precondition}\\
List of Job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} where t$_{i}$ is a task and c$_{i}$ is the time needed to complete the task. List of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}, where p$_{i}$ is a person, h$_{i}$ is the number of hours available to work for that person, and S$_{i}$ is an empty task list.\\
\\
\textbf{Postcondition}\\
\emph{Case 1 Not all tasks can be completed:} False value is returned.\\
\emph{Case 2 All tasks can be completed:} all S$_{i}$'s are updated to include name(s) of task(s) that p$_{i}$ participate(s) in. The updated P is returned.\\ 
\\
\textbf{Precondition $\implies$ Postcondition}\\ 
Assume the precondition holds. Using these values in J and P construct a bipartite graph where each p$_{i}$ has an edge aonnected to t$_{j}$, j $\in$ k (number of jobs). Once the bitpartite graph is constructed, add vertices S, a source, and T, a sink. Additionally, make each edge (p$_{i}$, t$_{j}$) directed, so that it exits p$_{i}$ and enters  t$_{j}$, also set c(p$_{i}$, t$_{j}$) = h$_{j}$. Make directed edges (S, p$_{i}$) with c(S, p$_{i}$) = h$_{j}$, and (t$_{j}$, T) with c(t$_{j}$, T) = c$_{j}$. Thus, we have a network flow that represents all possible ways a person could be assigned to the tasks given in J (lines 1 - 15). \\
Executing a modified Ford-Fulkerson procedure on this graph will produce a representation of maximum flow within the network. To see that a maximum flow in this graph represents tasks in a given day consider the following. Look at a flow path from S to a person, its capacity is the maximum number of hours this person can work. Similarly, for any task to T, the capacity is the necessary hours to complete the task. With edges in the original graph, from a person to each task, the number of hours a person can work limits the number of edges to a task that can have a flow greater than 0. Also, the number of hours of work that enter a task, by one or more people, is limited by the capacity of the edge between a task and vertex T. \\
If the maximum flow, returned by Ford-Fulkerson, does not equal $\sum_{i = 1}^{k}$ c$_{i}$ we return False. Clearly, not all tasks can be completed, and the postcondition holds for Case 1 (lines 25 - 27). Using the 'flow object' return for the modified Ford-Fulkerson, make a cut in the maximum flow representation of this graph between people vertices (u) and task vertices (v). Each person vertex corresponds to some p$_{i}$ in P, thus for any (u, v) where f(u, v) $\geqslant$ 1, find p$_{i}$ = u and then add task v to S$_{i}$. After updating all relevant S$_{i}$ return P, thus the postcondition holds for Case 2 (lines 17 - 24).\\
\\
\textbf{Termination}\\
Termination of the algorithm rests upon the completion of the Ford-Fulkerson procedure. Once there are no more augmenting paths from S to T  Ford-Fulkerson terminates. This is guarenteed to occur since the maimum flow is limited to $\sum_{i = 1}^{k}$ c$_{i}$ (by capacities edges from tasks to T), and each augmentation in Ford-Fulkerson increases flow by at least 1 unit. Additionally, Edmonds-Karp algorithm could be used, so termination would also be guaranteed. It follows that the algorithm must terminate as all other procedures are single iteration or for loops, which are guaranteed to complete given finite number of tasks and people.\\
$\blacksquare$\\    

% ----------------------------------------------------------------                                                                               
% Answer ends                                                                                                                                    
% ---------------------------------------------------------------- 


\end{description}
\end{document}
