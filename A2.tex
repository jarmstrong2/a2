% Title:   UofT Art & Sciences Assignment Sample File
% Version: 1.00
% Author:  Kaveh Ghasemloo
% Date:    Sept. 28, 2012
%
% Licence: 
% This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

\documentclass[10pt]{csc_assignment}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{qtree}

% ----------------------------------------------------------------
% TODO: Enter the assignment number, your name, and your student number below
% ----------------------------------------------------------------
\AssignmentName{2}
\QuestionCount{5}
\StudentName{John Armstrong, Henry Ku}
\StudentNumber{993114492\textbackslash g2jarmst, 998551348\textbackslash g2kuhenr}

% ----------------------------------------------------------------
\begin{document}


\Acknowledgements{
% ----------------------------------------------------------------
% TODO: Write your acknowledgements below.
% ----------------------------------------------------------------

"We declare that we have not used any outside help in completing this assignment."

% ----------------------------------------------------------------
% Aacknowledgements ends
% ----------------------------------------------------------------
}
\begin{description}

\newpage
\item[Q1.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{An nxn matrix R such that R[i, j] represents the ratio r$_{ij}$, also R[i, j] = 0 where i = j.}
 \KwOut{\emph{True} if we end up with more of our favourite marbles from some friend x$_{i}$ after initiating a marbling cycle, \emph{False} otherwise.}
 D$^{(0)} = R$\;
 \For{k: 1 ... n}{
 Let D$^{(k)}$ = d$_{ij}^{(k)}$ be an nxn matrix\;
 \For{i: 1 ... n}{
 \For{j: 1 ... n}{
 \If{i = k}{
 d$_{ij}^{(k)}$ = d$_{ij}^{(k-1)}$
 }
 \Else{
 d$_{ij}^{(k)}$ = max(d$_{ij}^{(k-1)}$, d$_{ik}^{(k-1)}$ * d$_{kj}^{(k-1)}$)\;
 }
 \If{d$_{ij}^{(k)}$ * r$_{ji}$ \textgreater ~1}{
 return True\;
 }
 }
 }
 }
 return False\;
\end{algorithm}
\emph{\underline{Running Time}}\\
\emph{Lines 2-16:} O(n$^{3}$) due to triple nested loop.\\
\emph{All other lines:} O(1).\\
\emph{\underline{Description}}\\
The algorithm is an augmented version of Floyd-Warshall as presented 
in CLRS. Because we do not know which series exchanges will give a 
total product greater than one, it makes sense to use an all-pairs
algorithm. However, instead of looking at each pass whether the
length of the path between a pair of vertices could be made more 
minimal we are looking for the a series of exchanges that connect
two vertices where the product of exchanges can be maximized.\\
Essentially the recursive definition is defined as follows:\\
\[
d_{ij}^{(k)} = 
\begin{cases} 
      \hfill r_{ij}    \hfill & \text{ if $k$ = 0} \\
      \hfill max(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} * d_{kj}^{(k-1)})\hfill & \text{ if $k$ $\geqslant$ 1} \\
  \end{cases}
\]\\
At each update of d$_{ij}^{(k)}$ we perform d$_{ij}^{(k)}$ * r$_{ji}$. 
If the result is greater than 1 then we have marbling cycle (cycle
 of exchanges) that is favourable. Thus True is returned. 
 False is returned if the algorithm cannot locate a favourable
 cycle.\\
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q2.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q3.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q4.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list \emph{A} of n houses and a list \emph{B} of m hospitals, where every house and hospital is represented by a pair (x, y) on the plane, and s and t}
 \KwOut{"Good" if each household has access to ahospital under the restrictions listed in the question, and "Eeek" otherwise.}
 \# Empty graph\;
 G(V, E)\;
 G.V = A $\cup$ B $\cup$ \{ T, S \} \;
 \For{i: 1 ... m}{
 G.addEdge(B[i], T)\;
 G.capacity(B[i], T) = t\
 }
 \For{j: 1 ... n}{
 G.addEdge(S, A[j])\;
 G.capacity(S, A[i]) = 1\;
 }
 \For{i: 1 ... m}{
 \For{j: 1 ... n}{
 \# d(u, v) is a distance function\;
 \If{d(A[j], B[i]) $\leqslant$ s}{ 
    G.addEdge(A[j], B[i])\; 
    G.capacity(A[j], B[i]) = 1\;
 }
 }
 } 
  \# Using the algorithm in CLRS Chap 26.2 with the assumptions that max flow for network G is returned\;
 maxFlow = FordFulkerson(G, S, T)\;
 \If{maxFlow = length(HS)}{
 return 'Good'\;
 }
 \Else{
 return 'Eeek!'\;
 }
 
\end{algorithm}
\emph{\underline{Description}}\\
The solution is to firstly generate a bipartite graph with which to perform maximum matching on.
This involves firstly iteratively connecting nodes i from A (houses) with an edge to node(s) j from B (hospitals) only if  d(i, j) $\leqslant$ s. Each of these edges is assigned c(i, j) = 1. From the bipartite graph we add two vertices S, the source, T, the sink, and make the edges in all (i, j) directed from i to j. S is connected to each node i in A by directed edge (S, i), also c(S, i) = 1. Also, each node j in B is connected to T by directed edge (j, T), and c(j, T) = t (the maximum number of houses a hospital can deal with). We then produce the maximum flow value by executing the Ford Fulkerson algorithm on the graph. If the maximum flow returned equals n, the number of houses, this means that there are an adaquate number of hospitals in the area.\\
\\
\\
\emph{\underline{Running Time}}\\
\emph{Lines 3 - 6:} O(m)\\
\emph{Lines: 7 - 10:} O(n)\\
\emph{Lines: 11 - 19:} O(mn)\\
\emph{Line 21:} Normally, Ford Fulkerson algorithm is O(E $\mid$f*$\mid$) (CLRS p. 725). In this case $\mid$f*$\mid$, the largest possible max flow, is n, the maximum number of houses. From our constructed bipartite graph, E = (all edges connected to S) + (all edges connected to T) + (all edges between houses and hospitals) $\leqslant$ O(n) + O(m) + O(mn), so E $\leqslant$ O(mn). Therefore line 23 is O(mn$^{2}$). \\
It follows that the algorithm is dominated by O(mn$^{2}$).\\
\\
\emph{\underline{Proof}}\\
\textbf{Claim}\\
Let G (V, E) be a bipartite graph with vertex partition V = A $\cup$ B, and with edge (u, v), u $\in$ A and v $\in$ B. Matches occur only when the d(v, u) is at most $s$, and at most $t$ edges can be matched to any u. Let M be the set of matching edges. Additionally, let G'(V', E') be the network flow graph constructed based on the algorithm description, and suppose the algorithm has completed (ie. there are no augmenting paths), assume that if returns a max flow f.\\ 
\textbf{(X)} M is a matching of G(V, E), and f = $\mid$M$\mid$. $\iff$ \textbf{(Y)} f is the maximum flow of G'(V', E'), and f = $\mid$M$\mid$.\\ 
\\
\textbf{(X$\implies$Y)}\\
Suppose M is a matching of G(V, E). We define f as follows. Begin by gathering all (u, v) $\in$ M, and make sets V$_{i}$ for each hospital v$_{i}$ to contain (u, v) where u $\in$ A and v = v$_{i}$. For each (u, v$_{i}$) $\in$ V$_{i}$, for all i, then it follows that in the G' representation f(S, u) = f(u, v$_{i}$) = 1. For all other edges (u, v) $\in$ E' not in M, let f(u, v) = 0. Then set f(v$_{i}$, T) = $\mid$V$_{i}$$\mid$ for each i. This follows constraint and flow conservation as outlined in the algorithm. By our definition of f, if we cut across (A $\cup$ {S}, B $\cup$ {T}) then f = $\sum_{i=1}^{m}$ V$_{i}$ = $\mid$M$\mid$, representing maximum flow in G'.\\
\\
\textbf{(Y$\implies$X)}\\
Let f be the maximum flow of G' as returned in the algorithm. Let M = \{(u, v) : u $\in$ A, v $\in$ B, and f(u, v) \textgreater ~0\}. Each vertex u in G' has a single entering edge, (S, u), and its capacity is 1. So, each u has at most one unit of flow entering it and, by conservation, one unit of flow leaving it. It follows for any (u, v) in M, by conservation, if a unit of flow enters u then a unit leaves u and must go into v, so f(u, v) = 1. For any v we have defined for (v, T) its capacity is t. Thus, if we have a series of edges {(u$_{1}$, v), ..., (u$_{k}$, v)} such that f(u$_{i}$, v) = 1 and k $\leqslant$ t since c(v, T) = t. It follows, by conservation, f(v, T) = k, since k single valued edges enter v. Therefore, M must be matching. Also, a cut across (A $\cup$ {S}, B $\cup$ {T}) in G' will be equal to $\mid$M$\mid$, as this is the closest representation of a bipartite graph between all (u, v)'s in M. By Max-Flow Min-Cut then f = f(A $\cup$ {S}, B $\cup$ {T}) = $\mid$M$\mid$. \\$\blacksquare$\\
    
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q5.]
% ----------------------------------------------------------------                                                                               
% TODO: Write your answer to the question below.                                                                                                 
% ----------------------------------------------------------------                                                                               

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list of job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} and a list of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}}
 \KwOut{If all tasks can be completed return a list of jobs each p$_{i}$ will have to complete, otherwise return false.}
\# Empty graph\\
G(V, E)\;
G.V = \{t$_{1}$, ..., t$_{k}$\} $\cup$ \{p$_{1}$, ..., p$_{n}$\} $\cup$ \{t, s\}\;
\For{i: 1 ... k}{
G.addEdge(t$_{i}$, T)\;
G.capacity(t$_{i}$, T) = c$_{i}$\;
\For{j: 1 ... n}{
G.addEdge(p$_{j}$, t$_{i}$)\;
G.capacity(p$_{j}$, t$_{i}$) = h$_{j}$\;
}
}
\For{j: 1 ... n}{
G.addEdge(S, p$_{j}$)\;
G.capacity(S, p$_{j}$) = h$_{j}$\;
}
Perform Ford-Fulkerson algorithm using G, assume the function returns some object, call it f. For any edge (u,v) in G, f(u,v) will be the flow through (u,v) where f as a whole represents a max flow through G.\\
\If{$\sum_{i = 1}^{k}$ c$_{i}$ = max flow in G (ie. if all tasks can be completed)}{
\ForEach{edge (u, v) in G}{
	\If{(u is a person and v is a task) and f(u, v) $\geqslant$ 1}{
		Get S$_{i}$ corresponding to u and add task v to S$_{i}$
	}
}
return P\;
}
\Else{
return False\;
} 
\end{algorithm}
\\
\emph{\underline{Proof of Correctness}}\\
\textbf{Precondition}\\
List of Job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} where t$_{i}$ is a task and c$_{i}$ is the time needed to complete the task. List of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}, where p$_{i}$ is a person, h$_{i}$ is the number of hours available to work for that person, and S$_{i}$ is an empty task list.\\
\\
\textbf{Postcondition}\\
\emph{Case 1 Not all tasks can be completed:} False value is returned.\\
\emph{Case 2 All tasks can be completed:} all S$_{i}$'s are updated to include name(s) of task(s) that p$_{i}$ participate(s) in. The updated P is returned.\\ 
\\
\textbf{Precondition $\implies$ Postcondition}\\ 
Assume the precondition holds. Using these values in J and P construct a bipartite graph where each p$_{i}$ has an edge aonnected to t$_{j}$, j $\in$ k (number of jobs). Once the bitpartite graph is constructed, add vertices S, a source, and T, a sink. Additionally, make each edge (p$_{i}$, t$_{j}$) directed, so that it exits p$_{i}$ and enters  t$_{j}$, also set c(p$_{i}$, t$_{j}$) = h$_{j}$. Make directed edges (S, p$_{i}$) with c(S, p$_{i}$) = h$_{j}$, and (t$_{j}$, T) with c(t$_{j}$, T) = c$_{j}$. Thus, we have a network flow that represents all possible ways a person could be assigned to the tasks given in J (lines 1 - 15). \\
Executing a modified Ford-Fulkerson procedure on this graph will produce a representation of maximum flow within the network. To see that a maximum flow in this graph represents tasks in a given day consider the following. Look at a flow path from S to a person, its capacity is the maximum number of hours this person can work. Similarly, for any task to T, the capacity is the necessary hours to complete the task. With edges in the original graph, from a person to each task, only a limited number of edges can have a flow greater than 0 because the number of hours that enters a person vertex must equal those that exits it. Also, the number of hours of work that enter a task, by one or more people, is limited by the capacity of the edge between a task and vertex T. \\
With the maximum flow representation of this graph we can determine maximum flow by the Max-Flow Min-Cut Theorem. If the maximum flow does not equal $\sum_{i = 1}^{k}$ c$_{i}$ we return False and the postcondition holds for Case 1 (lines 25 - 27). Otherwise, make a cut in the maximum flow representation of this graph between people vertices (u) and task vertices (v). Each person vertex corresponds to some p$_{i}$ in P, thus for any (u, v) where f(u, v) $\geqslant$ 1, find p$_{i}$ = u and then add task v to S$_{i}$. After updating all relevant S$_{i}$ return P, thus the postcondition holds for Case 2 (lines 17 - 24).\\
\\
\textbf{Termination}\\
Termination of the algorithm rests upon the completion of the Ford-Fulkerson procedure. Once there are no more augmenting paths from S to T  Ford-Fulkerson terminates. This is guarenteed to occur since the max flow is limited to $\sum_{i = 1}^{k}$ c$_{i}$, and each augmentation in Ford-Fulkerson increases flow by at least 1 unit. Additionally, Edmonds-Karp algorithm could be used, so termination would also be guaranteed. It follows that the algorithm must terminate as all other procedures are single iteration or for loops, which are guaranteed to complete given finite number of tasks and people.\\
$\blacksquare$\\    

% ----------------------------------------------------------------                                                                               
% Answer ends                                                                                                                                    
% ---------------------------------------------------------------- 


\end{description}
\end{document}
