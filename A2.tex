% Title:   UofT Art & Sciences Assignment Sample File
% Version: 1.00
% Author:  Kaveh Ghasemloo
% Date:    Sept. 28, 2012
%
% Licence: 
% This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

\documentclass[10pt]{csc_assignment}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{qtree}

% ----------------------------------------------------------------
% TODO: Enter the assignment number, your name, and your student number below
% ----------------------------------------------------------------
\AssignmentName{1}
\QuestionCount{5}
\StudentName{John Armstrong, Henry Ku}
\StudentNumber{993114492\textbackslash g2jarmst, 998551348\textbackslash g2kuhenr}

% ----------------------------------------------------------------
\begin{document}


\Acknowledgements{
% ----------------------------------------------------------------
% TODO: Write your acknowledgements below.
% ----------------------------------------------------------------

"We declare that we have not used any outside help in completing this assignment."

% ----------------------------------------------------------------
% Aacknowledgements ends
% ----------------------------------------------------------------
}
\begin{description}

\newpage
\item[Q1.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{An nxn matrix R such that R[i, j] represents the ratio r$_{ij}$, also R[i, j] = 0 where i = j.}
 \KwOut{\emph{True} if we end up with more of our favourite marbles from some friend x$_{i}$ after initiating a marbling cycle, \emph{False} otherwise.}
 D$^{(0)} = R$\;
 \For{k: 1 ... n}{
 Let D$^{(k)}$ = d$_{ij}^{(k)}$ be an nxn matrix\;
 \For{i: 1 ... n}{
 \For{j: 1 ... n}{
 \If{i = k}{
 d$_{ij}^{(k)}$ = d$_{ij}^{(k-1)}$
 }
 \Else{
 d$_{ij}^{(k)}$ = max(d$_{ij}^{(k-1)}$, d$_{ik}^{(k-1)}$ * d$_{kj}^{(k-1)}$)\;
 }
 \If{d$_{ij}^{(k)}$ * r$_{ji}$ \textgreater ~1}{
 return True\;
 }
 }
 }
 }
 return False\;
\end{algorithm}
\emph{\underline{Running Time}}\\
\emph{Lines 2-16:} O(n$^{3}$) due to triple nested loop.\\
\emph{All other lines:} O(1).\\
\emph{\underline{Description}}\\
The algorithm is an augmented version of Floyd-Warshall as presented 
in CLRS. Because we do not know which series exchanges will give a 
total product greater than one, it makes sense to use an all-pairs
algorithm. However, instead of looking at each pass whether the
length of the path between a pair of vertices could be made more 
minimal we are looking for the a series of exchanges that connect
two vertices where the product of exchanges can be maximized.\\
Essentially the recursive definition is defined as follows:\\
\[
d_{ij}^{(k)} = 
\begin{cases} 
      \hfill r_{ij}    \hfill & \text{ if $k$ = 0} \\
      \hfill max(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} * d_{kj}^{(k-1)})\hfill & \text{ if $k$ $\geqslant$ 1} \\
  \end{cases}
\]\\
At each update of d$_{ij}^{(k)}$ we perform d$_{ij}^{(k)}$ * r$_{ji}$. 
If the result is greater than 1 then we have marbling cycle (cycle
 of exchanges) that is favourable. Thus True is returned. 
 False is returned if the algorithm cannot locate a favourable
 cycle.\\
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q2.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q3.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q4.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list \emph{A} of n houses and a list \emph{B} of m hospitals, where every house and hospital is represented by a pair (x, y) on the plane, and s and t}
 \KwOut{"Good" if each household has access to ahospital under the restrictions listed in the question, and "Eeek" otherwise.}
 \# Empty graph\;
 G(V, E)\;
 G.V = A $\cup$ B $\cup$ \{ T, S \} \;
 \For{i: 1 ... m}{
 G.addEdge(B[i], T)\;
 G.capacity(B[i], T) = t\
 }
 \For{j: 1 ... n}{
 G.addEdge(S, A[j])\;
 G.capacity(S, A[i]) = 1\;
 }
 \For{i: 1 ... m}{
 \For{j: 1 ... n}{
 \# d(u, v) is a distance function\;
 \If{d(A[j], B[i]) $\leqslant$ s}{ 
    G.addEdge(A[j], B[i])\; 
    G.capacity(A[j], B[i]) = 1\;
 }
 }
 } 
  \# Using the algorithm in CLRS Chap 26.2 with the assumptions that max flow for network G is returned\;
 maxFlow = FordFulkerson(G, S, T)\;
 \If{maxFlow = length(HS)}{
 return 'Good'\;
 }
 \Else{
 return 'Eeek!'\;
 }
 
\end{algorithm}
\emph{\underline{Description}}\\
The solution is to generate a bipartite graph with which to perform maximum matching on.
This involves firstly iteratively connecting nodes i from A (houses) with a directed edge to node(s) i from B (hospitals) only if  d(i, j) $\leqslant$ s. Each of these edges is assigned c(i, j) = 1. Then two vertices S, the source, and T, the sink, are added to the graph. S is connected to each node i in A by directed edge (S, i), also c(S, i) = 1. Also, each node j in B is connected to T by directed edge (j, T), and c(j, T) = t (the maximum number of houses a hospital can deal with). We then produce the maximum flow value by executing the Ford Fulkerson algorithm on the graph. If the maximum flow returned equals n, the number of houses, this means that there are an adaquate number of hospitals in the area.\\
\emph{\underline{Running Time}}\\
\emph{Lines 3 - 6:} O(m)\\
\emph{Lines: 7 - 10:} O(n)\\
\emph{Lines: 11 - 19:} O(mn)\\
\emph{Line 21:} Normally, Ford Fulkerson algorithm is O(E $\mid$f*$\mid$) (CLRS p. 725). In this case $\mid$f*$\mid$, the largest possible max flow, is n, the maximum number of houses. From our constructed bipartite graph, E = (all edges connected to S) + (all edges connected to T) + (all edges between houses and hospitals) $\leqslant$ O(n) + O(m) + O(mn), so E $\leqslant$ O(mn). Therefore line 21 is O(mn$^{2}$). \\
It follows that the algorithm is dominated by O(mn$^{2}$).\\
\emph{\underline{Proof}}\\
\textbf{Claim}\\
Let G (V, E) be a bipartite graph with vertex partition V = A $\cup$ B, and with edge (u, v), u $\in$ A and v $\in$ B, such that the distance between v and u is at most $s$. Also, at most $t$ edges can be matched to any u. Additionally, let G'(V', E') be the network flow graph constructed based on the algorithm description, and suppose the algorithm has completed (ie. there are no augmenting paths).\\ 
(X$\implies$Y) If M is a matching of G(V, E) then f is the maximum flow of G'(V', E'), and f = M.\\ 
(Y$\implies$X) Conversely, if f is the maximum flow of G'(V', E'), then M is a matching of G(V, E), and M = f. \\
\textbf{(X$\implies$Y)}\\
Suppose M is a matching of G(V, E). Begin by gathering all (u, v) $\in$ M, and make sets V$_{i}$ for each hospital v$_{i}$ to contain (u, v) where u $\in$ A and v = v$_{i}$. It follows that each (u, v) $\in$ V$_{i}$ is equivalent to one unit flow as a path S $\rightarrow$ u $\rightarrow$ v in G', such that f(S, u) = f (u, v) = 1. It follows then that f(v, T) = $\mid$V$_{i}$.\\

% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q5.]
% ----------------------------------------------------------------                                                                               
% TODO: Write your answer to the question below.                                                                                                 
% ----------------------------------------------------------------                                                                               

SOLUTION

% ----------------------------------------------------------------                                                                               
% Answer ends                                                                                                                                    
% ---------------------------------------------------------------- 


\end{description}
\end{document}
