% Title:   UofT Art & Sciences Assignment Sample File
% Version: 1.00
% Author:  Kaveh Ghasemloo
% Date:    Sept. 28, 2012
%
% Licence: 
% This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

\documentclass[10pt]{csc_assignment}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{qtree}

% ----------------------------------------------------------------
% TODO: Enter the assignment number, your name, and your student number below
% ----------------------------------------------------------------
\AssignmentName{1}
\QuestionCount{5}
\StudentName{John Armstrong, Henry Ku}
\StudentNumber{993114492\textbackslash g2jarmst, 998551348\textbackslash g2kuhenr}

% ----------------------------------------------------------------
\begin{document}


\Acknowledgements{
% ----------------------------------------------------------------
% TODO: Write your acknowledgements below.
% ----------------------------------------------------------------

"We declare that we have not used any outside help in completing this assignment."

% ----------------------------------------------------------------
% Aacknowledgements ends
% ----------------------------------------------------------------
}
\begin{description}

\newpage
\item[Q1.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{An nxn matrix R such that R[i, j] represents the ratio r$_{ij}$, also R[i, j] = 0 where i = j.}
 \KwOut{\emph{True} if we end up with more of our favourite marbles from some friend x$_{i}$ after initiating a marbling cycle, \emph{False} otherwise.}
 D$^{(0)} = R$\;
 \For{k: 1 ... n}{
 Let D$^{(k)}$ = d$_{ij}^{(k)}$ be an nxn matrix\;
 \For{i: 1 ... n}{
 \For{j: 1 ... n}{
 \If{i = k}{
 d$_{ij}^{(k)}$ = d$_{ij}^{(k-1)}$
 }
 \Else{
 d$_{ij}^{(k)}$ = max(d$_{ij}^{(k-1)}$, d$_{ik}^{(k-1)}$ * d$_{kj}^{(k-1)}$)\;
 }
 \If{d$_{ij}^{(k)}$ * r$_{ji}$ \textgreater ~1}{
 return True\;
 }
 }
 }
 }
 return False\;
\end{algorithm}
\emph{\underline{Running Time}}\\
\emph{Lines 2-16:} O(n$^{3}$) due to triple nested loop.\\
\emph{All other lines:} O(1).\\
\emph{\underline{Description}}\\
The algorithm is an augmented version of Floyd-Warshall as presented 
in CLRS. Because we do not know which series exchanges will give a 
total product greater than one, it makes sense to use an all-pairs
algorithm. However, instead of looking at each pass whether the
length of the path between a pair of vertices could be made more 
minimal we are looking for the a series of exchanges that connect
two vertices where the product of exchanges can be maximized.\\
Essentially the recursive definition is defined as follows:\\
\[
d_{ij}^{(k)} = 
\begin{cases} 
      \hfill r_{ij}    \hfill & \text{ if $k$ = 0} \\
      \hfill max(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} * d_{kj}^{(k-1)})\hfill & \text{ if $k$ $\geqslant$ 1} \\
  \end{cases}
\]\\
At each update of d$_{ij}^{(k)}$ we perform d$_{ij}^{(k)}$ * r$_{ji}$. 
If the result is greater than 1 then we have marbling cycle (cycle
 of exchanges) that is favourable. Thus True is returned. 
 False is returned if the algorithm cannot locate a favourable
 cycle.\\
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q2.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q3.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------


% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q4.]
% ----------------------------------------------------------------
% TODO: Write your answer to the question below. 
% ----------------------------------------------------------------

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list \emph{A} of n houses and a list \emph{B} of m hospitals, where every house and hospital is represented by a pair (x, y) on the plane, and s and t}
 \KwOut{"Good" if each household has access to ahospital under the restrictions listed in the question, and "Eeek" otherwise.}
 \# Empty graph\;
 G(V, E)\;
 G.V = A $\cup$ B $\cup$ \{ T, S \} \;
 \For{i: 1 ... m}{
 G.addEdge(B[i], T)\;
 G.capacity(B[i], T) = t\
 }
 \For{j: 1 ... n}{
 G.addEdge(S, A[j])\;
 G.capacity(S, A[i]) = 1\;
 }
 \For{i: 1 ... m}{
 \For{j: 1 ... n}{
 \# d(u, v) is a distance function\;
 \If{d(A[j], B[i]) $\leqslant$ s}{ 
    G.addEdge(A[j], B[i])\; 
    G.capacity(A[j], B[i]) = 1\;
 }
 }
 } 
  \# Using the algorithm in CLRS Chap 26.2 with the assumptions that max flow for network G is returned\;
 maxFlow = FordFulkerson(G, S, T)\;
 \If{maxFlow = length(HS)}{
 return 'Good'\;
 }
 \Else{
 return 'Eeek!'\;
 }
 
\end{algorithm}
\emph{\underline{Description}}\\
The solution is to generate a bipartite graph with which to perform maximum matching on.
This involves firstly iteratively connecting nodes i from A (houses) with a directed edge to node(s) j from B (hospitals) only if  d(i, j) $\leqslant$ s. Each of these edges is assigned c(i, j) = 1. Then two vertices S, the source, and T, the sink, are added to the graph. S is connected to each node i in A by directed edge (S, i), also c(S, i) = 1. Also, each node j in B is connected to T by directed edge (j, T), and c(j, T) = t (the maximum number of houses a hospital can deal with). We then produce the maximum flow value by executing the Ford Fulkerson algorithm on the graph. If the maximum flow returned equals n, the number of houses, this means that there are an adaquate number of hospitals in the area.\\
\emph{\underline{Running Time}}\\
\emph{Lines 3 - 6:} O(m)\\
\emph{Lines: 7 - 10:} O(n)\\
\emph{Lines: 11 - 19:} O(mn)\\
\emph{Line 21:} Normally, Ford Fulkerson algorithm is O(E $\mid$f*$\mid$) (CLRS p. 725). In this case $\mid$f*$\mid$, the largest possible max flow, is n, the maximum number of houses. From our constructed bipartite graph, E = (all edges connected to S) + (all edges connected to T) + (all edges between houses and hospitals) $\leqslant$ O(n) + O(m) + O(mn), so E $\leqslant$ O(mn). Therefore line 21 is O(mn$^{2}$). \\
It follows that the algorithm is dominated by O(mn$^{2}$).\\
\emph{\underline{Proof}}\\
\textbf{Claim}\\
Let G (V, E) be a bipartite graph with vertex partition V = A $\cup$ B, and with edge (u, v), u $\in$ A and v $\in$ B, such that the distance between v and u is at most $s$. Also, at most $t$ edges can be matched to any u. Additionally, let G'(V', E') be the network flow graph constructed based on the algorithm description, and suppose the algorithm has completed (ie. there are no augmenting paths).\\ 
(X$\implies$Y) If M is a matching of G(V, E) then f is the maximum flow of G'(V', E'), and f = $\mid$M$\mid$.\\ 
(Y$\implies$X) Conversely, if f is the maximum flow of G'(V', E'), then M is a matching of G(V, E), and $\mid$M$\mid$ = f. \\
\textbf{(X$\implies$Y)}\\
Suppose M is a matching of G(V, E). We define f as follows. Begin by gathering all (u, v) $\in$ M, and make sets V$_{i}$ for each hospital v$_{i}$ to contain (u, v) where u $\in$ A and v = v$_{i}$. Then for all i, for each (u, v$_{i}$) $\in$ V$_{i}$, then f(S, u) = f (u, v$_{i}$) = 1. For all other edges (u, v) $\in$ E' not in M, let f(u, v) = 0. Then set f(v$_{i}$, T) = $\mid$V$_{i}$$\mid$ for each i. This follows constraint and flow conservation as outlined in the algorithm. By our definition of f, if we cut across (A $\cup$ {S}, B $\cup$ {T}) then f = $\sum_{i=1}^{m}$ V$_{i}$ = $\mid$M$\mid$.\\
\textbf{(Y$\implies$X)}\\
Let f be the maximum flow of G' as returned in the algorithm. Let M = \{(u, v) : u $\in$ A, v $\in$ B, and f(u, v) \textgreater ~0\}. Each vertex u in G' has a single entering edge, (S, u), and its capacity is 1. So, each u has at most one unit of flow entering it and, by conservation, one unit of flow leaving it. It follows that if a unit of flow enters u then a unit leaves u and must go into v, so f(u, v) = 1. For any v we have defined for (v, T) its capacity as t. Thus, if we have a series of edges {(u$_{1}$, v), ..., (u$_{k}$, v)} such that f(u$_{i}$, v) = 1 and k $\leqslant$ t. It follows, by conservation, f(v, T) = k, since k single valued edges enter v. Therefore, M must be matching. Also, a cut across (A $\cup$ {S}, B $\cup$ {T}) in G' will be equal to $\mid$M$\mid$. By Max-Flow Min-Cut then f = f(A $\cup$ {S}, B $\cup$ {T}) = $\mid$M$\mid$. $\blacksquare$\\
    
% ----------------------------------------------------------------
% Answer ends
% ----------------------------------------------------------------

\newpage
\item[Q5.]
% ----------------------------------------------------------------                                                                               
% TODO: Write your answer to the question below.                                                                                                 
% ----------------------------------------------------------------                                                                               

\emph{\underline{Algorithm}}\\
\begin{algorithm}[H]
 \LinesNumbered 
 \KwIn{A list of job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} and a list of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}}
 \KwOut{If all tasks can be completed return a list of jobs each p$_{i}$ will have to complete, otherwise return false.}
\# Empty graph\\
G(V, E)\;
G.V = \{t$_{1}$, ..., t$_{k}$\} $\cup$ \{p$_{1}$, ..., p$_{n}$\} $\cup$ \{t, s\}\;
\For{i: 1 ... k}{
G.addEdge(t$_{i}$, T)\;
G.capacity(t$_{i}$, T) = c$_{i}$\;
\For{j: 1 ... n}{
G.addEdge(p$_{j}$, t$_{i}$)\;
G.capacity(p$_{j}$, t$_{i}$) = h$_{j}$\;
}
}
\For{j: 1 ... n}{
G.addEdge(S, p$_{j}$)\;
G.capacity(S, p$_{j}$) = h$_{j}$\;
}
Perform Ford-Fulkerson algorithm using G, assume the function returns some object, call it f. For any edge (u,v) in G, f(u,v) will be the flow through (u,v) where f as a whole represents a max flow through G.\\
\If{$\sum_{i = 1}^{k}$ c$_{i}$ = max flow in G (ie. if all tasks can be completed)}{
\ForEach{edge (u, v) in G}{
	\If{(u is a person and v is a task) and f(u, v) $\geqslant$ 1}{
		Get S$_{i}$ corresponding to u and add task v to S$_{i}$
	}
}
return P\;
}
\Else{
return False\;
} 
\end{algorithm}
\emph{\underline{Proof of Correctness}}\\
\textbf{Precondition}\\
List of Job objects J = \{(t$_{1}$, c$_{1}$), ..., (t$_{k}$, c$_{k}$)\} where t$_{i}$ is a task and c$_{i}$ is the time needed to complete the task. List of people/staff objects P = \{(p$_{1}$, h$_{1}$, S$_{1}$), ..., (p$_{n}$, h$_{n}$, S$_{n}$)\}, where p$_{i}$ is a person, h$_{i}$ is the number of hours available to work for that person, and S$_{i}$ is an empty task list.\\
\textbf{Postcondition}\\
\emph{Case 1 Not all tasks can be completed:} False value is returned.\\
\emph{Case 2 All tasks can be completed:} all S$_{i}$'s are updated to include names of task(s) that p$_{i}$ participate(s) in. The updated P is returned.\\ 
\textbf{Precondition $\implies$ Postcondition}\\ 
Assume the precondition holds. Using these values in J and P construct a bipartite graph where each p$_{i}$ has an edge entering each t$_{j}$, j $\in$ k (number of jobs) and c(p$_{i}$, t$_{j}$) = h$_{j}$. Once the bitpartite graph is constructed, add vertices S, a source, and T, a sink. Make edges (S, p$_{i}$) with c(S, p$_{i}$) = h$_{j}$, and (t$_{j}$, T) with c(t$_{j}$, T) = c$_{j}$. Thus, we have a network flow that represents all possible ways a person could be assigned to the tasks given in J (lines 1 - 15). Executing a Ford-Fulkerson procedure on this graph will produce a maximum flow within the network. To see that a maximum flow in this graph represents tasks in a given day consider the following. Look at a flow path from S to a person, its capacity is the maximum number of hours this person can work. Similarly, for any task to T, the capacity is the necessary hours to complete the task. With edges in the original graph, from a person to each task, only a limit number of edges can have a flow greater than 1 because the number of hours that exits a person vertex must equal those that enter it. Also, the number of hours of work that enter a task is limited by the capacity of the edge connected to T.\\    

% ----------------------------------------------------------------                                                                               
% Answer ends                                                                                                                                    
% ---------------------------------------------------------------- 


\end{description}
\end{document}
